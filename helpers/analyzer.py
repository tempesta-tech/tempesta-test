"""
Instruments for network traffic analysis.
"""

from __future__ import print_function

import abc

from scapy.all import *

from helpers import error, remote, util
from helpers.tf_cfg import test_logger

__author__ = "Tempesta Technologies, Inc."
__copyright__ = "Copyright (C) 2017-2025 Tempesta Technologies, Inc."
__license__ = "GPL2"


FIN = 0x01
SYN = 0x02
RST = 0x04
PSH = 0x08
ACK = 0x10
URG = 0x20
ECE = 0x40
CWR = 0x80


class Sniffer(object, metaclass=abc.ABCMeta):

    def __init__(self, node: remote.ANode, host, count=0, timeout=30, ports=(80,), node_close=True):
        self.node = node
        self.ports = ports
        self.thread = None
        self.captured = 0
        self.packets = []
        self.dump_file = "/tmp/tmp_packet_dump"
        str_ports = " or ".join(("tcp port %s" % p) for p in ports)
        # TODO #120: it's bad to use timeout(1). Instead we should run
        # the tcpdump process and kill it when the test is done.
        cmd = "timeout %s tcpdump -i any -n %s -w - %s || true"
        count_flag = ("-c %s" % count) if count else ""
        self.cmd = cmd % (timeout, count_flag, str_ports)
        self.err_msg = " ".join(["Can't %s sniffer on", host])
        self.node_side_close = node_close

    def sniff(self):
        """Thread function for starting system sniffer and saving
        its output. We need to use temporary file here, because
        scapy.sniff(offline=file_obj) interface does not support
        neither StringIO objects nor paramiko file objects.
        """
        stdout, stderr = self.node.run_cmd(self.cmd, timeout=None)
        match = re.search(r"(\d+) packets captured", stderr.decode())
        if match:
            self.captured = int(match.group(1))
        with open(self.dump_file, "wb") as f:
            f.write(stdout)

    def start(self):
        self.thread = Thread(target=self.sniff)
        self.thread.start()
        util.wait_until(lambda: not self.thread.is_alive())

    def stop(self):
        if self.thread:
            self.thread.join()
            if os.path.exists(self.dump_file):
                self.packets = sniff(count=self.captured, offline=self.dump_file)
                os.remove(self.dump_file)
            else:
                error.bug('Dump file "%s" does not exist!' % self.dump_file)


class AnalyzerCloseRegular(Sniffer):
    def __init__(self, *args, **kwargs):
        Sniffer.__init__(self, *args, **kwargs)
        self.port = self.ports[0]

    def portcmp(self, packet, invert=False):
        if self.node_side_close and invert:
            return packet[TCP].dport == self.port
        elif self.node_side_close and not invert:
            return packet[TCP].sport == self.port
        elif not self.node_side_close and invert:
            return packet[TCP].sport == self.port
        else:
            return packet[TCP].dport == self.port

    def check_results(self):
        """Four-way (FIN-ACK-FIN-ACK) and
        three-way (FIN-ACK/FIN-ACK) handshake order checking.
        """
        if not self.packets:
            return False

        test_logger.debug("AnalyzerCloseRegular: FIN sequence:")

        count_seq = 0
        l_seq = 0
        for p in self.packets:
            if p[TCP].flags & RST:
                return False
            if count_seq >= 4:
                return False
            if count_seq == 0 and p[TCP].flags & FIN and self.portcmp(p):
                l_seq = p[TCP].seq + p[IP].len - p[IP].ihl * 4 - p[TCP].dataofs * 4
                count_seq += 1
                continue
            if count_seq == 1 and p[TCP].flags & ACK and self.portcmp(p, invert=True):
                if p[TCP].ack > l_seq:
                    count_seq += 1
            if count_seq == 2 and p[TCP].flags & FIN and self.portcmp(p, invert=True):
                l_seq = p[TCP].seq + p[IP].len - p[IP].ihl * 4 - p[TCP].dataofs * 4
                count_seq += 1
                continue
            if count_seq == 3 and p[TCP].flags & ACK and self.portcmp(p):
                if p[TCP].ack > l_seq:
                    count_seq += 1

        if count_seq != 4:
            return False

        return True


class AnalyzerTCPSegmentation(Sniffer):
    """Compare TCP segments generated by the original server with segments
    generated by Tempesta TLS: we should see not smaller TCP segments here.
    However, this shouldn't be strict - in some circumstances TCP/IP stack
    may split skbs in non optimal way. Probably the test must be relaxed in
    some sense.
    """

    def __init__(self, *args, **kwargs):
        Sniffer.__init__(self, *args, **kwargs)
        self.tfw_port = self.ports[0]
        self.srv_port = self.ports[1]
        self.srv_pkts = []
        self.tfw_pkts = []

    def check_results(self, client_ip):
        tls_offset = 5
        res = True
        for p in self.packets:
            if (p.dst or p.src) == client_ip:
                plen = p[IP].len - p[TCP].dataofs
                if p[TCP].sport == self.tfw_port:
                    self.tfw_pkts += [int(plen)]
                elif p[TCP].sport == self.srv_port:
                    self.srv_pkts += [int(plen)]
                test_logger.info(
                    f"pkt:{p.payload.sport} -> {p.dst}:{p.payload.dport} len_{p.len} id_{p.id_}"
                )
        self.srv_pkts.pop(0)  # Exclude first ack
        tls_offset = self.tfw_pkts.index(self.srv_pkts[0])  # Find payload offset
        self.tfw_pkts.pop(tls_offset + 1)  # Exclude heades
        (tfw_n, srv_n) = (len(self.tfw_pkts), len(self.srv_pkts))
        tfw_sent = tfw_n - tls_offset  # TLS handshake
        srv_sent = srv_n  # Ack packet
        assert tfw_n and srv_n, "Traffic wasn't captured"
        assert tfw_n >= 6, "Captured the number of packets less than" " the TCP/TLS overhead"
        assert srv_sent != 0, "Backend not sent payload"
        assert tfw_sent != 0, "Tempesta not sent payload"
        # Tempesta cant generate less payload packets cause we overheaded by TLS
        # + Header addition. So we check the number of sent packets is equal
        if tfw_sent != srv_sent:
            test_logger.warning(
                f"Tempesta TLS generates more packets ({tfw_sent}) than"
                f" original server ({srv_sent})"
            )
            res = False
        test_logger.debug(
            "Tempesta segments len: %s\nServer segments len: %s"
            % (sum(self.tfw_pkts[tls_offset:]), sum(self.srv_pkts)),
        )
        test_logger.debug(
            "Tempesta\Server len delta: %s"
            % (sum(self.tfw_pkts[tls_offset:]) - sum(self.srv_pkts)),
        )
        test_logger.debug(
            "Tempesta segments: %s\nServer segments: %s"
            % (str(self.tfw_pkts[tls_offset:]), str(self.srv_pkts)),
        )
        self.first_run = False
        return res


# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
